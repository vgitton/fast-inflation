#pragma once

#include "../events/event.h"
#include "symmetry.h"

#include <map>
#include <set>

/*! \file */

namespace inf {

/*! \defgroup orbits Event orbits
 * \ingroup symmetry
 * \brief Equipping inf::EventTensor with symmetry-induced orbits of events.
 *
 * The idea is that both inf::TargetDistr and inf::DualVector have orbits.
 * To avoid code duplication, we make both of these class inherit from inf::TensorWithOrbits.
 * To simplify the presentation of inf::TensorWithOrbits, we first formulate the class inf::Orbitable,
 * which simply describes an object that holds a set of events divided into orbits generated by a symmetry group.
 * The class inf::TensorWithOrbits then extends the class inf::Orbitable by adding suitable method for accessing
 * the data of an inf::EventTensor that is also an inf::Orbitable.
 * */

/*! \ingroup orbits
    \brief Something that holds symmetry-induced orbits of events.

    In other words, something that has a symmetry group acting on events and for which the orbits are relevant, such as an inf::TargetDistr or an inf::DualVector.
    \note It would be possible to merge inf::Orbitable with inf::TensorWithOrbits. Somehow, dividing the two classes like this feels a bit more natural and easier
    to read, but this is arguably subjective.
    */
class Orbitable {
  public:
    // Typedefs

    /*! \brief An orbit is a set of events pertaining to a symmetry-induced equivalence class */
    typedef std::set<inf::Event> Orbit;
    /*! \brief Maps each representative (of an orbit) inf::Event to its corresponding inf::Orbitable::Orbit
    \details For instance,
    \code{.cpp}
    inf::Orbitable::OrbitMap orbit_map;
    // The event {0,0,0} is the representative of the orbit {n,n,n} for n in 0,1,2,3:
    orbit_map[{0,0,0}] = inf::Orbitable::Orbit({{0,0,0},{1,1,1},{2,2,2},{3,3,3}});
    // etc...
    \endcode */
    typedef std::map<inf::Event, inf::Orbitable::Orbit> OrbitMap;
    /*! \brief This type is useful for iteration: the pair is of the form `(representative,orbit)`.
    \details For instance,
    \code{.cpp}
    inf::Orbitable::OrbitMap orbit_map = ...; // Here set up orbit_map
    for(inf::Orbitable::OrbitPair const& orbit_pair : orbit_map)
    {
        // orbit_pair.first is the representative event
        // orbit_pair.second is the set of events of the equivalence class (which includes orbit_pair.first)
    }
    \endcode */
    typedef std::pair<const inf::Event, inf::Orbitable::Orbit> OrbitPair;

    // Constructor

    /*! \brief Default constructor that does not initialize anything, the child class must call inf::Orbitable::init_orbits() */
    explicit Orbitable();
    //! \cond
    Orbitable(Orbitable const &other) = delete;
    Orbitable(Orbitable &&other) = delete;
    Orbitable &operator=(Orbitable const &other) = delete;
    Orbitable &operator=(Orbitable &&other) = delete;
    //! \endcond

    // Getters

    /*! \brief This returns the underlying symmetry group */
    inf::Symmetry::Group const &get_sym_group() const;
    /*! \brief The number of orbits produced (only sensible after inf::Orbitable::init_orbits() has been called) */
    Index get_n_orbits() const;
    /*! \brief Returns the underlying inf::Orbitable::OrbitMap */
    inf::Orbitable::OrbitMap const &get_orbits() const;
    /*! \brief Return `true` if `inf::Orbitable::init_orbits()` has been called */
    bool orbits_initialized() const { return m_orbits_initialized; }

    // Strings

    /*! \brief Logs short one-line info about number of orbits */
    void log_sym_group() const;
    /*! \brief Logs long multi-line info about orbits
        \param shorten If `false`, then the full orbits are printed out,
            otherwise only the first few elements are */
    void log_orbits(bool shorten) const;

    // Pure virtuals

    /*! \brief Logs an event, e.g., `(0,0,2)`
        \param event Event to be logged */
    virtual void log_event(inf::Event const &event) const = 0;
    /*! \brief Returns the inf::EventRange over which inf::Orbitable is defined, used in inf::Orbitable::init_orbits() */
    virtual inf::EventRange get_event_range() const = 0;
    /*! \brief Specifies the number of events supporting the inf::Orbitable
        \details This matches the size of inf::Orbitable::get_event_range() */
    virtual Index get_n_events() const = 0;
    /*! \brief Specifies the number of parties (i.e., the length of the events supporting the inf::Orbitable)
        \details This matches with the size of each inf::Event contained in inf::Orbitable::get_event_range() */
    virtual Index get_n_parties() const = 0;

  private:
    /*! \brief Maps each representative (of an orbit) inf::Event to its corresponding inf::Orbitable::Orbit */
    inf::Orbitable::OrbitMap m_orbits;

  protected:
    /*! \brief Child classes have to call this method for initialization of the orbits.
     * \details The class contains soft assertions to check that this method was indeed called.
        \note This method is not in the constructor to allow the child class to do non-trivial
        computations before choosing the symmetry group.
        \param sym_group Technically, this is not required to be a group, but in all applications this
        will be a group. */
    void init_orbits(inf::Symmetry::Group const &sym_group);

  private:
    /*! \brief `true` if inf::Orbitable::init_orbits() has been called */
    bool m_orbits_initialized;
    /*! \brief The list of symmetries (typically a group) that generates the orbits */
    inf::Symmetry::Group m_sym_group;
};

} // namespace inf
